/* PohLang Phase 1 — Formal Grammar (EBNF)
   Authoritative draft for parser implementation (Phase 1)

   Notes:
   - Statements must be separated by newlines or a semicolon `;`.
   - Blocks use explicit terminators: End If, End While, End Repeat, End Function, End Program
   - Keywords are case-insensitive in implementation but canonical form shown in grammar (lowercase tokens allowed in source).
   - This grammar is intentionally strict: no synonyms and fixed phrasing.

   This file contains:
   1) Lexical tokens
   2) EBNF grammar for statements, expressions, control flow, and functions
   3) Semantic notes and parser implementation suggestions (PEG-friendly)
*/

########################
# 1. Lexical tokens
########################

digit       = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
integer     = digit , { digit } ;
identifier  = letter , { letter | digit | "_" } ;
letter      = ? any ASCII letter ? ;

string      = '"' , { any-character-except-quote } , '"' ;

newline     = %x0A | %x0D %x0A ;    /* LF or CRLF */
ws          = ( " " | "\t" | newline ) ;
sep         = ws | ";" ;           /* statement separator */

########################
# 2. Simple literals
########################

NumberLiteral = integer ;
StringLiteral = string ;

########################
# 3. Program structure
########################

program      = opt-bom , program-header , { statement , separator } , program-footer ;
program-header = "Start Program" , separator ;
program-footer = "End Program" ;

separator    = ( newline , { ws } ) | ";" ;
opt-bom      = /* optional BOM handled by lexer */ ;

########################
# 4. Top-level statements
########################

statement    = write-stmt
             | set-stmt
             | ask-stmt
             | inc-dec-stmt
             | if-stmt
             | while-stmt
             | repeat-stmt
             | function-def
             | function-call-stmt
             | return-stmt
             ;

write-stmt   = "Write" , ws1 , expression ;

set-stmt     = "Set" , ws1 , identifier , ws1 , "to" , ws1 , expression ;

ask-stmt     = "Ask for" , ws1 , identifier , [ ws1 , ask-constraints ] ;
ask-constraints = ( "expect" , ws1 , type-name ) | ( "with" , ws1 , StringLiteral ) ;

inc-dec-stmt = ( "Increase" , ws1 , identifier , ws1 , "by" , ws1 , expression )
             | ( "Decrease" , ws1 , identifier , ws1 , "by" , ws1 , expression )
             ;

function-call-stmt = function-call ;
function-call = identifier , "(" , [ argument-list ] , ")" ;
argument-list = expression , { "," , ws* , expression } ;

return-stmt  = "Return" , ws1 , expression ;

########################
# 5. Control flow
########################

if-stmt      = "If" , ws1 , condition , separator , { statement , separator }
               , [ "Else" , separator , { statement , separator } ]
               , "End If" ;

while-stmt   = "While" , ws1 , condition , separator , { statement , separator } , "End While" ;

repeat-stmt  = "Repeat" , ws1 , NumberLiteral , ws1 , "times" , separator , { statement , separator } , "End Repeat" ;

########################
# 6. Functions
########################

function-def = "Function" , ws1 , identifier , "(" , [ param-list ] , ")" , separator
               , { statement , separator }
               , "End Function" ;

param-list   = identifier , { "," , ws* , identifier } ;

/* Inline shorthand not included in Phase 1 by design. */

########################
# 7. Expressions & operators
########################

expression   = equality ;

/* precedence climbing:    lowest -> highest
   equality (==, !=) -> comparison -> add/sub -> mul/div -> primary */

equality     = comparison , { ( ws1 , ("is equal to" | "is not equal to") , ws1 ) , comparison } ;
comparison   = additive , { ( ws1 , ("is less than" | "is greater than" | "is less than or equal to" | "is greater than or equal to") , ws1 ) , additive } ;
additive     = multiplicative , { ( ws1 , ("plus" | "minus") , ws1 ) , multiplicative } ;
multiplicative = primary , { ( ws1 , ("times" | "divided by") , ws1 ) , primary } ;

primary      = NumberLiteral
             | StringLiteral
             | function-call
             | identifier
             | "(" , expression , ")"
             ;

condition    = expression ; /* conditions are any expression that evaluates to boolean */

########################
# 8. Types & builtins
########################

type-name = "Number" | "String" ;

########################
# 9. Semantic notes
########################

/*
1. Case sensitivity: identifiers are case-sensitive; keywords are case-insensitive in the lexer.
2. Error messages: the runtime should provide friendly guidance (spelling suggestions recommended).
3. Handling "Ask for" conversions: try Number parse first if ask expects Number, else treat as String.
4. Division: consider runtime error for division by zero (Phase 1) — friendly message.
5. Return semantics: a function without explicit Return returns a null/none value.
6. Closures and advanced scoping: postpone to Phase 2; for Phase 1, functions capture globals by value only (or disallow capturing) — pick one.
*/

########################
# 10. Parser implementation suggestions
########################

/*
- PEG (parsing expression grammar) or a recursive descent parser is recommended for this phrasal language.
- Use a lexer to combine multi-word operators into single token (e.g., "divided by", "is less than").
- Require explicit statement separators (newline or semicolon) to avoid ambiguity in streaming source.
- Prefer a two-pass approach: 1) Lex/Tokenize (combine multiword tokens), 2) Parse with precedence-aware parser.
*/

########################
# 11. Example programs (short)
########################

/*
Start Program

Write "Enter your name:";
Ask for name;

If name is equal to "Alice"
    Write "Hello Alice!";
Else
    Write "Hello Stranger!";
End If

Set count to 1;
Repeat 5 times
    Write "Loop number " plus count;
    Increase count by 1;
End Repeat

Function square(x)
    Return x times x;
End Function

Write "Square of 4 is " plus square(4);

End Program
*/
